---
title: "Malnutrition Masterscript"
author: "Jim Perry"
date: "5/30/2022"
output: pdf_document
---

```{r Install Required Packages}
```
install.packages("readxl")
install.packages("dplyr")
install.packages("VIM")
install.packages("fastDummies")
install.packages("anthroplus")
install.packages("caret")
install.packages("tidyverse")
install.packages("smotefamily")
install.packages("broom")
install.packages("car")
install.packages("performance")
install.packages("MASS")
install.packages("plyr")
install.packages("mRMRe")
install.packages("praznik")
install.packages("glmnet")
install.packages("leaps")
install.packages("arules")
install.packages("arulesViz")
install.packages("epitools")
install.packages("DescTools")
install.packages("rlang")
install.packages("rmcfs") #monte carlo FS
install.packages("rpart") #CART 
install.packages("WebPower") #LR psuedoR2
install.packages("power")
install.packages("randomForest")

# PREPROCESSING: Preparing data from original survey for use in statistical/ML analysis.
#####
```{r Import Data}
#Reading and cleaning the original spreadsheet from the survey.
library(readxl)
library(dplyr)

SURVEY = read_excel("SURVEY.xlsx")
SURVEY = SURVEY[-1,] #First row is a misread full of NAs - drop it
SURVEY = SURVEY[,-c(35, 54, 115, 134)] #Empty columns

#Now the fun part - manually rename any weird variable names
names(SURVEY)[13] = "Class" #Which class in the grade is the child in?
names(SURVEY)[17] = "FamilySize"
names(SURVEY)[18] = "NumOldBros"
names(SURVEY)[19] = "Bros<12?"
names(SURVEY)[20] = "Vaccine"
names(SURVEY)[21] = "BCGScar"
names(SURVEY)[22] = "FeverLast2Weeks"
names(SURVEY)[23] = "FeverQuantity"
names(SURVEY)[24] = "DiarrheaLast2Weeks"
names(SURVEY)[25] = "DiarrheaQuantity"
names(SURVEY)[26] = "CoughLast2Weeks"
names(SURVEY)[27] = "CoughQuantity"
names(SURVEY)[28] = "NailsTrimmed"
names(SURVEY)[29] = "NailsDirty"
names(SURVEY)[30] = "NailTrimFrequency"
names(SURVEY)[31] = "SchoolLat"
names(SURVEY)[32] = "SchoolLatDoors"
names(SURVEY)[33] = "SchoolLatFlies"
names(SURVEY)[34] = "SchoolLatVisibleStool"
names(SURVEY)[35] = "HeardOfAL"
names(SURVEY)[36] = "HeardOfTT"
names(SURVEY)[37] = "HeardOfHW"
names(SURVEY)[38] = "HeardOfHIV"
names(SURVEY)[39] = "HeardOfWorms"
names(SURVEY)[40] = "HeardOfMalaria"
names(SURVEY)[41] = "HeardOfTB"
names(SURVEY)[42] = "HeardOfSCh"
names(SURVEY)[43] = "ToldByFam"
names(SURVEY)[44] = "ToldByHP"
names(SURVEY)[45] = "ToldByTeacher"
names(SURVEY)[46] = "ToldByMedia"
names(SURVEY)[47] = "KnowWormsSpread"
names(SURVEY)[48] = "HowKnowWormsSpread"
names(SURVEY)[49] = "KnowWormsBad"
names(SURVEY)[50] = "HowKnowWormsBad"
names(SURVEY)[51] = "KnowAvoidWorms"
names(SURVEY)[52] = "HowKnowAvoidWorms"
names(SURVEY)[53] = "WhereLive"
names(SURVEY)[54] = "Address"
names(SURVEY)[55] = "Occupation"
names(SURVEY)[56] = "MomEduc"
names(SURVEY)[57] = "HouseFloorMats"
names(SURVEY)[58] = "KitchenSeparate"
names(SURVEY)[59] = "SepKitchenMats"
names(SURVEY)[60] = "SepKitchenRoof"
names(SURVEY)[61] = "SepKitchenWall"
names(SURVEY)[62] = "SepKitchenNeither" #Should be able to get removed in 1HE
names(SURVEY)[63] = "CookWood"
names(SURVEY)[64] = "CookGas"
names(SURVEY)[65] = "CookCoal"
names(SURVEY)[66] = "CookKerosine"
names(SURVEY)[67] = "CookElectric"
names(SURVEY)[68] = "Electricity"
names(SURVEY)[69] = "Radio"
names(SURVEY)[70] = "TV"
names(SURVEY)[71] = "Phone"
names(SURVEY)[72] = "WhyPhone"
names(SURVEY)[73] = "Cattle"
names(SURVEY)[74] = "SheepGoat"
names(SURVEY)[75] = "Chicken"
names(SURVEY)[76] = "HousePet"
names(SURVEY)[77] = "NoAnimal"
names(SURVEY)[78] = "HouseHasWater"
names(SURVEY)[79] = "WhereGetWater"
names(SURVEY)[80] = "WaterTreated"
names(SURVEY)[81] = "HowTreat"
names(SURVEY)[82] = "FamLat"
names(SURVEY)[83] = "LatInside"
names(SURVEY)[84] = "LatDistanceHouse"
names(SURVEY)[85] = "LatDistanceKitchen"
names(SURVEY)[86] = "LatConnectedTo"
names(SURVEY)[87] = "RiverBathFrequency"
names(SURVEY)[88] = "RiverLaundryFrequency"
names(SURVEY)[89] = "DefecateField"
names(SURVEY)[90] = "UseSchoolLat"
names(SURVEY)[91] = "UseTP"
names(SURVEY)[92] = "WashHandsLat"
names(SURVEY)[93] = "WashHandsLatHow"
names(SURVEY)[94] = "WashHandsSoapLatFrequency"
names(SURVEY)[95] = "WashHandsEat"
names(SURVEY)[96] = "WashHandsEatHow"
names(SURVEY)[97] = "WashHandsSoapEatFrequency"
names(SURVEY)[98] = "EatSoil"
names(SURVEY)[99] = "FavFruit"
names(SURVEY)[100] = "WashFruit"
names(SURVEY)[101] = "EatRawVeg"
names(SURVEY)[102] = "WashRawVegFrequency"
names(SURVEY)[103] = "WalkBarefoot"
names(SURVEY)[104] = "HomeShoeOrSandal"
names(SURVEY)[105] = "ForWhatBarefoot"
names(SURVEY)[106] = "DewormPill"
names(SURVEY)[107] = "WhenDewormPill"
names(SURVEY)[108] = "Antibiotics"
names(SURVEY)[109] = "MostFreqFood"
names(SURVEY)[110] = "TakesMeds"
names(SURVEY)[111] = "Name/TypeOfMeds"
names(SURVEY)[112] = "AntiMalaria3Months"
names(SURVEY)[113] = "Wheezing"
names(SURVEY)[114] = "Wheezing2Yrs"
names(SURVEY)[115] = "Wheezing1Yr"
names(SURVEY)[116] = "Wheezing1YrQuantity"
names(SURVEY)[117] = "Asthma"
names(SURVEY)[118] = "Asthma2Yrs"
names(SURVEY)[119] = "Asthma1Yr"
names(SURVEY)[120] = "DocConfirmedAsthma"
names(SURVEY)[121] = "Rash"
names(SURVEY)[122] = "RashElbow"
names(SURVEY)[123] = "RashKnees"
names(SURVEY)[124] = "RashAnkles"
names(SURVEY)[125] = "RashButt"
names(SURVEY)[126] = "RashNeck"
names(SURVEY)[127] = "RashEyesEars"
names(SURVEY)[128] = "HayFever"
names(SURVEY)[129] = "HayFever2Yrs"
names(SURVEY)[130] = "HayFever1Yr"

SURVEY = SURVEY[,-c(1, 7, 8, 9)] #Don't need these columns; I forgot to remove them earlier
```



```{r Handling NAs & Datatype Conversions, warning = FALSE}
reducedSurvey = SURVEY[,-c(44, 46, 48, 51, 64, 95, 101, 105, 107)] #Potential candidates for removal from dataset; we'll work with this, as I think these changes will end up in the final iteration.
################################################################################
#1HE "Where do you get your water from?"
tapWater = c()
WaterFromNeighbor = c()
WaterFromRiver = c()
WaterFromWell = c()
WaterFromTank = c()

for (i in 1:1036){
  if (is.na(reducedSurvey[[i, 70]])){
    tapWater[[i]] = 0
    WaterFromNeighbor[[i]] = 0
    WaterFromRiver[[i]] = 0
    WaterFromWell[[i]] = 0
    WaterFromTank[[i]] = 0
    next
  }
  if (tolower(reducedSurvey[[i, 70]]) == "tap water"){
    tapWater[[i]] = 1
    WaterFromNeighbor[[i]] = 0
    WaterFromRiver[[i]] = 0
    WaterFromWell[[i]] = 0
    WaterFromTank[[i]] = 0
  }else if (reducedSurvey[[i, 70]] == 0){
    tapWater[[i]] = 0
    WaterFromNeighbor[[i]] = 1
    WaterFromRiver[[i]] = 0
    WaterFromWell[[i]] = 0
    WaterFromTank[[i]] = 0
  }else if (reducedSurvey[[i, 70]] == 1){
    tapWater[[i]] = 0
    WaterFromNeighbor[[i]] = 0
    WaterFromRiver[[i]] = 1
    WaterFromWell[[i]] = 0
    WaterFromTank[[i]] = 0
  }else if (reducedSurvey[[i, 70]] == 2){
    tapWater[[i]] = 0
    WaterFromNeighbor[[i]] = 0
    WaterFromRiver[[i]] = 0
    WaterFromWell[[i]] = 1
    WaterFromTank[[i]] = 0
  }else if (reducedSurvey[[i, 70]] == 4){
    tapWater[[i]] = 0
    WaterFromNeighbor[[i]] = 0
    WaterFromRiver[[i]] = 0
    WaterFromWell[[i]] = 0
    WaterFromTank[[i]] = 1
  }
}
tapWater = as.numeric(as.character(tapWater))
reducedSurvey[[70]] = tapWater
names(reducedSurvey)[[70]] = "WaterFromTap"

WaterFromNeighbor = as.numeric(as.character(WaterFromNeighbor))
reducedSurvey[[117]] = WaterFromNeighbor
names(reducedSurvey)[[117]] = "WaterFromNeighbor"

WaterFromRiver = as.numeric(as.character(WaterFromRiver))
reducedSurvey[[118]] = WaterFromRiver
names(reducedSurvey)[[118]] = "WaterFromRiver"

WaterFromWell = as.numeric(as.character(WaterFromWell))
reducedSurvey[[119]] = WaterFromWell
names(reducedSurvey)[[119]] = "WaterFromWell"

WaterFromTank = as.numeric(as.character(WaterFromTank))
reducedSurvey[[120]] = WaterFromTank
names(reducedSurvey)[[120]] = "WaterFromTank"

################################################################################
#1HE Rural/Suburban/Urban split
rural = c()
urban = c()
for (i in 1:1036){
  if (is.na(reducedSurvey[[i, 46]])){
      next
  }
  neighborhood = reducedSurvey[[i, 46]]
  if(neighborhood == 0){
      urban[[i]] = 1
      rural[[i]] = 0
  }else if(neighborhood == 1){
    rural[[i]] = 1
    urban[[i]] = 0
    }
}
urban = as.numeric(as.character(urban))
reducedSurvey[[46]] = urban
names(reducedSurvey)[[46]] = "Urban"
rural = as.numeric(as.character(rural)) #Can't convert directly from double to numeric
reducedSurvey[[47]] = rural# = replace(reducedSurvey, reducedSurvey$Address, rural)
names(reducedSurvey)[[47]] = "Rural"
################################################################################
#Remove units from measurements so they can be converted to numerics
for (i in 1:1036){
  distance = reducedSurvey[[i, 75]]
  reducedSurvey[[i, 75]] = substr(distance, 1, length(distance))
  distance2 = reducedSurvey[[i, 76]]
  reducedSurvey[[i, 76]] = substr(distance2, 1, length(distance2))
  whenDeworm = reducedSurvey[[i, 96]]
  reducedSurvey[[i, 96]] = substr(whenDeworm, 1, length(whenDeworm))

}
reducedSurvey[[75]] = as.numeric(reducedSurvey[[75]]) #Can typecast directly to numeric
reducedSurvey[[76]] = as.numeric(reducedSurvey[[76]])
reducedSurvey[[96]] = as.numeric(reducedSurvey[[96]])
################################################################################
#These factors have number measurements but are of datatype "character"; simple conversion to datatype "numeric"
changeInds = c(19, 21, 23, 31:42, 50:59, 64:68, 72, 76, 77, 82:117)
for (factor in changeInds){
  reducedSurvey[[factor]] = as.numeric(reducedSurvey[[factor]])
}
################################################################################
#Drop "Class"? Doesn't seem specific enough to be useful.
reducedSurvey = reducedSurvey[, -9]
################################################################################
#Adjusting data values
#Convert "99"s in numeric factors to "Na"s for later imputation under kNN algorithm
for (sample in 1:1036){
  for (factor in 11:116) #Columns where 99s indicate "I don't know" as a possible answer
    if (is.na(reducedSurvey[[sample, factor]])){
      next
    }else if (reducedSurvey[[sample, factor]] == 99){
      reducedSurvey[[sample, factor]] = NA
    }
}

#A sample's height was misinput as 92.00 meters. Very impressive, but not useful
for (sample in 1:1036){
  if (reducedSurvey[[sample, 10]] == 92.00){ 
    reducedSurvey[[sample, 10]] = NA
    break
  }
}

#Impute conditional responses where "NA" implies 0
for (sample in 1:1036){
  for (factor in c(18, 20, 22, 31:41, 53, 55:58, 64:67, 71, 95, 109:113)){
    if (is.na(reducedSurvey[[sample, factor]])){
      reducedSurvey[[sample, factor]] = 0
    }
  }
}

#These columns were input as a different binary; as "NA/0" instead of "0/1"
for (sample in 1:1036){
  for (factor in c(30, 54, 63)){ 
    if (is.na(reducedSurvey[[sample, factor]])){
      reducedSurvey[[sample, factor]] = 0
    }else if (reducedSurvey[[sample, factor]] == 0){
      reducedSurvey[[sample, factor]] = 1
    }else{
      reducedSurvey[[sample, factor]] = 0
    }
  }
}

#Convert different numeric binaries 0/2 binaries into 0/1
for (sample in 1:1036){
  for (factor in c(49, 65)){
    if (is.na(reducedSurvey[[sample, factor]])){
      next
    }else if (reducedSurvey[[sample, factor]] == 2){
      reducedSurvey[[sample, factor]] = 1
    }else if (reducedSurvey[[sample, factor]] != 0){
      reducedSurvey[[sample, factor]] = NA
    }
  }
}
#CookElectric's binary is 0/4; converting into 0/1
for (sample in 1:1036){{
    if (is.na(reducedSurvey[[sample, 58]])){
      next
    }else if (reducedSurvey[[sample, 58]] == 4){
      reducedSurvey[[sample, 58]] = 1
    }else if (reducedSurvey[[sample, 58]] != 0){
      reducedSurvey[[sample, 58]] = NA
    }
  }
}
#0/3 here
for (sample in 1:1036){{
    if (is.na(reducedSurvey[[sample, 66]])){
      reducedSurvey[[sample, 66]] = 0
    }else if (reducedSurvey[[sample, 66]] == 3){
      reducedSurvey[[sample, 66]] = 1
    }else if (reducedSurvey[[sample, 6]] != 0){
      reducedSurvey[[sample, 66]] = NA
    }
  }
}
#I don't know why this code in the above loop doesn't work. I don't know why it does work when placed into its own loop. Code is mysterious; let's hope this desire for loop autonomy doesn't spread
for (sample in 1:1036){{
    if (is.na(reducedSurvey[[sample, 66]])){
      reducedSurvey[[sample, 66]] = 0
    }
  }
}

#copySet = reducedSurvey
#reducedSurvey = copySet

#Setting weird values in binary vectors (anything that's not 0/1) to NA for imputation
for (sample in 1:1036){
  for (factor in c(15, 16, 21, 23, 24, 49, 51, 58, 65, 68, 72:73)){
    if (is.na(reducedSurvey[[sample, factor]])){
      next
    }else if ((reducedSurvey[[sample, factor]] != 0) & (reducedSurvey[[sample, factor]] != 1)){
      reducedSurvey[[sample, factor]] = NA
    }
  }
}



reducedSurvey$HouseFloorMats = tolower(reducedSurvey$HouseFloorMats)

#Getting rid of some more weird values
for (sample in 1:1036){
  for (factor in c(85:86))
  if (is.na(reducedSurvey[[sample, factor]])){
    next
  }
  else if (reducedSurvey[[sample, factor]] == 21 || reducedSurvey[[sample, factor]] == 10){
    reducedSurvey[[sample, factor]] = NA
  }
}

for (sample in 1:1036){
  if (is.na(reducedSurvey[[sample, 10]])){
    next
  }
  else if (reducedSurvey[[sample, 10]] == 1.79){ #misinput in survey
    reducedSurvey[[sample, 10]] = 1.29
  }
}

```



```{r One Hot Encoding}
library(VIM)
library(fastDummies)

#1HE nominal categoricals
#I already encoded some of these by hand in the last code block, but the remainder can be handled by this imported function
oneHotEncoded = dummy_cols(.data = reducedSurvey,
                     ignore_na = TRUE,
                     remove_first_dummy =  TRUE,
                     split = ",")
oneHotEncoded = oneHotEncoded[,-c(48, 123)] #One category got broken up and the other was created to account for a sample answer that got misinput as both
```



```{r Final Layer of Data Handling, warning = FALSE}
#Handle variables we decided to remove or calculate differently.
processed = oneHotEncoded[, -c(1:5, 11, 13:14, 18, 20, 22, 25:26, 30:44, 49, 52:56, 61, 66, 70, 73:75, 83, 86, 92, 94, 99:104, 107:112, 114, 119:121, 127)]

#Encode mother's education
for (i in 1:1036){
  education = processed[[i, 19]]
  if (is.na(education)){
    processed$momFinishedPrimary[[i]] = NA
    processed$momFinishedSecondary[[i]] = NA
    processed$momFinishedTertiary[[i]] = NA
    next
  }
  processed$momFinishedPrimary[[i]] = 0
  processed$momFinishedSecondary[[i]] = 0
  processed$momFinishedTertiary[[i]] = 0
  if (education == 1){
    processed$momFinishedPrimary[[i]] = 1
  }else if (education == 2){
    processed$momFinishedSecondary[[i]] = 1
  }else if (education == 3){
    processed$momFinishedTertiary[[i]] = 1
  }
}

processed$momFinishedPrimary = as.numeric(as.character(processed$momFinishedPrimary))
processed$momFinishedSecondary = as.numeric(as.character(processed$momFinishedSecondary))
processed$momFinishedTertiary = as.numeric(as.character(processed$momFinishedTertiary))
processed = processed[, -19]

#Convert house floor materials into a binary for whether that floor is dust or not
for (i in 1:1036){
  if (is.na(sum(processed[i,61:65]))){
    processed$houseDustFloor[[i]] = NA
    next
  }
  if (sum(processed[i,61:65]) > 0){
    processed$houseDustFloor[[i]] = 0
  }else{
    processed$houseDustFloor[[i]] = 1
  }
}
processed$houseDustFloor = as.numeric(as.character(processed$houseDustFloor))
processed = processed[,-c(61:65)]

#Converting 1/2 binaries to 0/1
for (sample in 1:1036){
  for (factor in 53:56){
    if(is.na(processed[sample,factor])){
      next
    }
    if (processed[sample, factor] == 2){
      processed[sample, factor] = 0
    }
  }
}

#Every sample has the same answer for this variable - it tells us nothing
processed = processed[,-c(21)]
processed = processed[,-3]

#1HE washing hands after lat into "never", "with water", and "with soap" groups
for (i in 1:1036){
  if (is.na(processed[[i,38]])){
    processed$washHandsLatWater[[i]] = NA
    processed$washHandsLatWaterSoap[[i]] = NA
    next
  }
  else if (processed[[i,38]] == 2){
    processed$washHandsLatWater[[i]] = 0
    processed$washHandsLatWaterSoap[[i]] = 0
  }else{
    if (is.na(processed[[i,39]])){
      processed$washHandsLatWater[[i]] = NA
      processed$washHandsLatWaterSoap[[i]] = NA
      next
    }
    else if (processed[[i, 39]] == 0){
      processed$washHandsLatWater[[i]] = 1
      processed$washHandsLatWaterSoap[[i]] = 0
    }else if (processed[[i, 39]] == 1){
      processed$washHandsLatWater[[i]] = 0
      processed$washHandsLatWaterSoap[[i]] = 1
    }
  }
}
processed$washHandsLatWater = as.numeric(as.character(processed$washHandsLatWater))
processed$washHandsLatWaterSoap = as.numeric(as.character(processed$washHandsLatWaterSoap))
processed = processed[, -c(38:39)]

#1HE washing hands before eat into "never", "with water", "with soap" groups
for (i in 1:1036){
  if (is.na(processed[[i,38]])){
    processed$washHandsWaterB4Eat[[i]] = NA
    processed$washHandsSoapB4Eat[[i]] = NA
    next
  }
  else if (processed[[i,38]] == 2){
    processed$washHandsWaterB4Eat[[i]] = 0
    processed$washHandsSoapB4Eat[[i]] = 0
  }else{
    if (is.na(processed[[i,39]])){
      processed$washHandsWaterB4Eat[[i]] = NA
      processed$washHandsSoapB4Eat[[i]] = NA
      next
    }
    else if (processed[[i, 39]] == 0){
      processed$washHandsWaterB4Eat[[i]] = 1
      processed$washHandsSoapB4Eat[[i]] = 0
    }else if (processed[[i, 39]] == 1){
      processed$washHandsWaterB4Eat[[i]] = 0
      processed$washHandsSoapB4Eat[[i]] = 1
    }
  }
}
processed$washHandsWaterB4Eat = as.numeric(as.character(processed$washHandsWaterB4Eat))
processed$washHandsSoapB4Eat = as.numeric(as.character(processed$washHandsSoapB4Eat))
processed = processed[, -c(38:39)]

#Change ternary variables into binaries based on biological significance
for (sample in 1:1036){
  for (factor in c(33:37)){
    if (is.na(processed[[sample, factor]])){
      processed[[sample, factor]] = NA
      next
    }
    else if (processed[[sample, factor]] == 2){
      processed[[sample, factor]] = 0
    }else{
      processed[[sample, factor]] = 1
    }
  }
}
names(processed)[[33]] = "RiverBathing"
names(processed)[[34]] = "RiverLaundry"

for (sample in 1:1036){
  if (is.na(processed[[sample, 38]])){
    processed[[sample, 38]] = NA
    next
  }
 else if (processed[[sample, 38]] == 1){
   processed[[sample, 38]] = 0
 }else{
   processed[[sample, 38]] = 1
 }
}

for (sample in 1:1036){
  if (is.na(processed[[sample, 39]])){
    processed[[sample, 39]] = NA
    next
  }
  else if (processed[[sample, 39]] != 0){
    processed[[sample, 39]] = 0
  }else if (processed[[sample, 39]] == 0){
    processed[[sample, 39]] = 1
  }
}
names(processed)[[39]] = "NeverWashFruit"

#More ternary variables, but split differently according to biological significance
for (sample in 1:1036){
  for (factor in c(40:42)){
    if (is.na(processed[[sample, factor]])){
      processed[[sample, factor]] = NA
      next
    }
    else if (processed[[sample, factor]] != 0){
      processed[[sample, factor]] = 1
    }else{
      processed[[sample, factor]] = 0
    }
  }
}

#This loop below does two things: it re-formats data so 0 is false and 1 is true, OR turns already-correct but useless data into correctly-encoded data (i.e. "NoPhone" and "NoWaterInHouse")
for (sample in 1:1036){
  for (factor in c(11,13,23,31,32,36,37)){
    if (is.na(processed[[sample, factor]])){
      processed[[sample, factor]] = NA
      next
    }
    else if (processed[[sample, factor]] == 1){
      processed[[sample, factor]] = 0
    }else{
      processed[[sample, factor]] = 1
    }
  }
}
names(processed)[[11]] = "NailsNotTrimmed"
names(processed)[[13]] = "NoSchoolLatDoors"
names(processed)[[23]] = "NoPhone"
names(processed)[[28]] = "PotableWaterFromHouse"
names(processed)[[30]] = "DontTreatWater"
names(processed)[[31]] = "NoFamLat"
names(processed)[[32]] = "LatOutside"
names(processed)[[36]] = "DontUseSchoolLat"
names(processed)[[37]] = "DontUseTP"

for (i in 1:1036){
  if ((!is.na(processed[[i,8]]) & processed[[i,8]] == 1) |
      (!is.na(processed[[i,9]]) & processed[[i,9]] == 1) |
      (!is.na(processed[[i,10]]) & processed[[i,10]] == 1)){
    processed$SickLast2Weeks[i] = 1
  }else if (is.na(processed[[i,8]]) | is.na(processed[[i,9]]) | is.na(processed[[i,10]])){
    processed$SickLast2Weeks[i] = NA
  }else{
    processed$SickLast2Weeks[i] = 0
  }
}
processed = processed[,-c(8:10)]

for (i in 1:1036){
  if ((!is.na(processed[[i,8]]) & processed[[i,8]] == 1) |
      (!is.na(processed[[i,9]]) & processed[[i,9]] == 1)){
    processed$NailsMaintained[i] = 0
  }else if (is.na(processed[[i,8]]) | is.na(processed[[i,9]])){
    processed$NailsMaintained[i] = NA
  }else{
    processed$NailsMaintained[i] = 1
  }
}
processed = processed[,-c(8:10)]

for (i in 1:1036){
  if ((!is.na(processed[[i,8]]) & processed[[i,8]] == 1) |
      (!is.na(processed[[i,9]]) & processed[[i,9]] == 1)){
    processed$SchoolLatClean[i] = 0
  }else if (is.na(processed[[i,8]]) | is.na(processed[[i,9]])){
    processed$SchoolLatClean[i] = NA
  }else{
    processed$SchoolLatClean[i] = 1
  }
}
processed = processed[,-c(8:9, 11)]
processed = processed[,-c(10)]

for (i in 1:1036){
  if ((!is.na(processed[[i,11]]) & processed[[i,11]] == 1) |
      (!is.na(processed[[i,12]]) & processed[[i,12]] == 1)){
    processed$"Radio/TV"[i] = 1
  }else if (is.na(processed[[i,11]]) | is.na(processed[[i,12]])){
    processed$"Radio/TV"[i] = NA
  }else{
    processed$"Radio/TV"[i] = 0
  }
}
processed = processed[,-c(11:12)]
processed = processed[,-11]

processed = processed[,-c(16, 18)]

for (i in 1:1036){
  if ((!is.na(processed[[i,18]]) & processed[[i,18]] == 1) |
      (!is.na(processed[[i,19]]) & processed[[i,19]] == 1)){
    processed$RiverCleaning[i] = 1
  }else if (is.na(processed[[i,18]]) | is.na(processed[[i,19]])){
    processed$RiverCleaning[i] = NA
  }else{
    processed$RiverCleaning[i] = 0
  }
}
processed = processed[,-c(18,19)]

for (i in 1:1036){
  if ((!is.na(processed[[i,28]]) & processed[[i,28]] == 1) |
      (!is.na(processed[[i,29]]) & processed[[i,29]] == 1)){
    processed$OtherMeds[i] = 1
  }else if (is.na(processed[[i,28]]) | is.na(processed[[i,29]])){
    processed$OtherMeds[i] = NA
  }else{
    processed$OtherMeds[i] = 0
  }
}
processed = processed[,-c(28,29)]
processed = processed[,-28]
processed = processed[,-c(30:34)]

for (i in 1:1036){
  if ((!is.na(processed[[i,31]]) & processed[[i,31]] == 1) |
      (!is.na(processed[[i,32]]) & processed[[i,32]] == 1)){
    processed$"momFinished2Up"[i] = 1
  }else if (is.na(processed[[i,31]]) | is.na(processed[[i,32]])){
    processed$"momFinished2Up"[i] = NA
  }else{
    processed$"momFinished2Up"[i] = 0
  }
}
processed = processed[,-c(31, 32)]
names(processed)[[12]] = "SheepGoat"
names(processed)[[39]] = "RadioTV"
```



```{r Dependent Variable Calculations}
#Derive WAZ/HAZ/BAZ for specific analysis
#WAZ: Weight-relative-to-age Z-score (WHO says unreliable for ages 11+, so ignore older kids)
#HAZ: Height-relative-to-age Z-score 
#BAZ: BMI-relative-to-age Z-score

library(anthroplus)

depVars = anthroplus_zscores(sex = processed[["Sex"]]+1,
                             age_in_months = processed[["Age"]]*12,
                             weight_in_kg = processed[["weight"]],
                             height_in_cm = processed[["Height"]]*100
                             )

for (i in 1:1036){
  ZHeight = depVars$zhfa[[i]]
  processed$HAZ[[i]] = ZHeight
  processed$Stunting[[i]] = ifelse(ZHeight < -2, 1, 0 )
  
  ZBMI = depVars$zbfa[[i]]
  processed$BAZ[[i]] = ZBMI
  processed$Thinness[[i]] = ifelse (ZBMI < -2, 1, 0)
  
  if (processed[[i,"Age"]] < 11){ #scores not calculated for children 11 and up
    ZWeight = depVars$zwfa[[i]]
    processed$WAZ[[i]] = ZWeight
    processed$Wasting[[i]] = ifelse (ZWeight < -2, 1, 0)
  }else{
    processed$WAZ[[i]] = NA
    processed$Wasting[[i]] = NA
  }
}

processed$HAZ = as.numeric(as.character(processed$HAZ))
processed$Stunting = as.numeric(as.character(processed$Stunting))
processed$BAZ = as.numeric(as.character(processed$BAZ))
processed$Thinness = as.numeric(as.character(processed$Thinness))

#Some samples were too old/young for the WHO's package to calculate Stunting scores; we will remove them
for (i in 1:1036){
  if (is.na(processed$Stunting[i])){
    processed = processed[-i,]
  }
}
```



```{r Saving Preprocessing, Imputation}
library(randomForest)
################################################################################
Stunting = processed[,-c(3, 4, 43, 45:48)]

#kNN imputation
imputed = kNN(Stunting, variable = colnames(Stunting), k = 5, impNA = TRUE) 
Stunting_kNN = subset(imputed, select = 1:41)

#RF imputation
Stunting_RF = rfImpute(Stunting~., Stunting)
Stunting_RF = round(Stunting_RF, digits = 0)
y = Stunting_RF[,1]
Stunting_RF = Stunting_RF[,-1]
Stunting_RF[,41] = y
names(Stunting_RF)[[41]] = "Stunting"

# % identical imputation between each method
1 - sum(Stunting_RF!=Stunting_kNN) / sum(is.na(Stunting)) #90.3% the same - shouldn't have an issue regardless of imputation method
sum(is.na(Stunting))

Stunting = Stunting_kNN #keep as kNN so future code works

################################################################################
Thinness = processed[,-c(3, 4, 43:45, 47:48)]

#kNN imputation
imputed = kNN(Thinness, variable = colnames(Thinness), k = 5, impNA = TRUE) 
Thinness_kNN = subset(imputed, select = 1:41)

#RF imputation
Thinness_RF = rfImpute(Thinness~., Thinness)
Thinness_RF = round(Thinness_RF, digits = 0)
y = Thinness_RF[,1]
Thinness_RF = Thinness_RF[,-1]
Thinness_RF[,41] = y
names(Thinness_RF)[[41]] = "Thinness"

# % identical imputation between each method
1 - sum(Thinness_RF!=Thinness_kNN) / sum(is.na(Thinness)) #88.4%
sum(is.na(Thinness))

Thinness = Thinness_kNN

################################################################################
Wasting = processed[,-c(3, 4, 43:47)]

#kNN imputation
Wasting = subset(Wasting, Age < 11) #Wasting can't be calculated for age >11
Wasting$Wasting = as.numeric(as.character(Wasting$Wasting))
imputed = kNN(Wasting, variable = colnames(Wasting), k = 5, impNA = TRUE)
Wasting_kNN = subset(imputed, select = 1:41)

#RF imputation
Wasting_RF = rfImpute(Wasting~., Wasting)
Wasting_RF = round(Wasting_RF, digits = 0)
y = Wasting_RF[,1]
Wasting_RF = Wasting_RF[,-1]
Wasting_RF[,41] = y
names(Wasting_RF)[[41]] = "Wasting"

 #% identical imputation between each method
1 - sum(Wasting_RF!=Wasting_kNN) / sum(is.na(Wasting)) #89.7%
sum(is.na(Wasting))

Wasting = Wasting_kNN

#write.csv(Stunting, "Stunting.csv")
#write.csv(Thinness, "Thinness.csv")
#write.csv(Wasting, "Wasting.csv")
```



```{r Data Structure Preparation, Subsetting}
# Stunting = read.csv("Stunting.csv")
# Thinness = read.csv("Thinness.csv")
# Wasting = read.csv("Wasting.csv")
################################################################################
DATA = list("Stunting" = list("Full" = list(),
                              "Urban" = list(),
                              "Nonurban" = list(),
                              "Male" = list(),
                              "Female" = list(),
                              "Youth" = list(),
                              "Adolescent" = list()
                              ),
            "Thinness" = list("Full" = list(),
                              "Urban" = list(),
                              "Nonurban" = list(),
                              "Male" = list(),
                              "Female" = list(),
                              "Youth" = list(),
                              "Adolescent" = list()
                              ),
            "Wasting" = list("Full" = list(),
                              "Urban" = list(),
                              "Nonurban" = list(),
                              "Male" = list(),
                              "Female" = list()
                              )
            )
################################################################################
DATA[["Stunting"]][["Full"]] = Stunting
DATA[["Stunting"]][["Urban"]] = subset(Stunting, Urban == 1)
DATA[["Stunting"]][["Nonurban"]] = subset(Stunting, Urban == 0)
DATA[["Stunting"]][["Male"]] = subset(Stunting, Sex == 0)
DATA[["Stunting"]][["Female"]] = subset(Stunting, Sex == 1)
DATA[["Stunting"]][["Youth"]] = subset(Stunting, Age < 11)
DATA[["Stunting"]][["Adolescent"]] = subset(Stunting, Age > 10)
################################################################################
DATA[["Thinness"]][["Full"]] = Thinness
DATA[["Thinness"]][["Urban"]] = subset(Thinness, Urban == 1)
DATA[["Thinness"]][["Nonurban"]] = subset(Thinness, Urban == 0)
DATA[["Thinness"]][["Male"]] = subset(Thinness, Sex == 0)
DATA[["Thinness"]][["Female"]] = subset(Thinness, Sex == 1)
DATA[["Thinness"]][["Youth"]] = subset(Thinness, Age < 11)
DATA[["Thinness"]][["Adolescent"]] = subset(Thinness, Age > 10)
################################################################################
DATA[["Wasting"]][["Full"]] = Wasting
DATA[["Wasting"]][["Urban"]] = subset(Wasting, Urban == 1)
DATA[["Wasting"]][["Nonurban"]] = subset(Wasting, Urban == 0)
DATA[["Wasting"]][["Male"]] = subset(Wasting, Sex == 0)
DATA[["Wasting"]][["Female"]] = subset(Wasting, Sex == 1)
#No Youth/Adolescent splits for Wasting; it's already limited to samples < 11 years old
```



```{r FS Splits}
library(caret)
library(tidyverse)
library(smotefamily)
library(VIM)
set.seed(13)

FSSets = list("Stunting" = list("Full" = list(),
                            "Urban" = list(),
                            "Nonurban" = list(),
                            "Male" = list(),
                            "Female" = list(),
                            "Youth" = list(),
                            "Adolescent" = list()
                            ),
            "Thinness" = list("Full" = list(),
                              "Urban" = list(),
                              "Nonurban" = list(),
                              "Male" = list(),
                              "Female" = list(),
                              "Youth" = list(),
                              "Adolescent" = list()
                              ),
            "Wasting" = list("Full" = list(),
                              "Urban" = list(),
                              "Nonurban" = list(),
                              "Male" = list(),
                              "Female" = list()
                              )
            )
index = 0
for (i in 1:3){
  for (j in 1:7){
    if (i == 3 & (j == 6 | j == 7)){
      next
    }
    index = index + 1
     FSSets[[i]][[j]] = list()#"Unbalanced" = list(),
                         # "Balanced" = list()
                         # )
    set = DATA[[i]][[j]]
    response = names(DATA)[i]
    
    outerFolds = createFolds(set[,41], k = 10) #Create k splits
    Unbalanced = list(set[-outerFolds$Fold01, ], #Remove 10% of the data for each set
                          set[-outerFolds$Fold02, ], #to give us 10 different subsets
                          set[-outerFolds$Fold03, ],
                          set[-outerFolds$Fold04, ],
                          set[-outerFolds$Fold05, ],
                          set[-outerFolds$Fold06, ],
                          set[-outerFolds$Fold07, ],
                          set[-outerFolds$Fold08, ],
                          set[-outerFolds$Fold09, ],
                          set[-outerFolds$Fold10, ]
                          )
    for (k in 1:10){
      curSet = Unbalanced[[k]]
      innerFolds = createFolds(curSet[,41], k = 10)
      Unbalanced[[k]] = list(curSet[-innerFolds$Fold01, ], #Same as above but for
                            curSet[-innerFolds$Fold02, ], #sets we already have. 10*10 = 100
                            curSet[-innerFolds$Fold03, ],
                            curSet[-innerFolds$Fold04, ],
                            curSet[-innerFolds$Fold05, ],
                            curSet[-innerFolds$Fold06, ],
                            curSet[-innerFolds$Fold07, ],
                            curSet[-innerFolds$Fold08, ],
                            curSet[-innerFolds$Fold09, ],
                            curSet[-innerFolds$Fold10, ]
                            )
    }
  FSSets[[i]][[j]] = Unbalanced
  }
}
```

# FEATURE SELECTION:
####################

```{r Feature Selection, warning=FALSE, output=FALSE, echo=FALSE, results='hide'}
#NOTE: This will take about 5 minutes to run
set.seed(13)
library(broom)
library(car)
library(performance)
library(MASS)
#Preparing data structure to store results

NUM_FEATURES = 10 #Change this for different feature selection cutoffs
FSResults = list("Stunting" = list("Full" = list(),
                                   "Urban" = list(),
                                   "Nonurban" = list(),
                                   "Male" = list(),
                                   "Female" = list(),
                                   "Youth" = list(),
                                   "Adolescent" = list()
                                   ),
                 "Thinness" = list("Full" = list(),
                                   "Urban" = list(),
                                   "Nonurban" = list(),
                                   "Male" = list(),
                                   "Female" = list(),
                                   "Youth" = list(),
                                   "Adolescent" = list()
                                   ),
                 "Wasting" = list("Full" = list(),
                                  "Urban" = list(),
                                  "Nonurban" = list(),
                                  "Male" = list(),
                                  "Female" = list(),
                                  "Youth" = list(),
                                  "Adolescent" = list()
                                  )
                 )
for (i in 1:3){
  for (j in 1:7){
    FSResults[[i]][[j]] = list("MLR" = list(),
                               "ChiSq" = list(),
                               "mRMR" = list(),
                               "JMI" = list(),
                               "MC" = list()
                               )
  }
}
################################################################################
#Beginning loop iterations, filling out data structure
for (i in 1:3){
  for (j in 1:7){
      if (i == 3 & (j == 6 | j == 7)){ #Wasting has no youth/adolescent subsets; skip them
        next
      }
      FeatureList = data.frame(Feature = character(),
                               MLR = double(),
                               ChiSq = double(),
                               mRMR = double(),
                               JMI = double(),
                               MC = double()
                               )
      for (k in 1:40){ #Make score markers for all features to track importance
        FeatureList[[k,1]] = names(Stunting)[k] #Name every row
        for (k1 in 2:6){
          FeatureList[[k,k1]] = 0 #Set initial scores for all 6 FS methods to 0
        }
      }
      for (k in 1:10){
        for (l in 1:10){
          data = FSSets[[i]][[j]][[k]][[l]] #Load specific dataset we'll use in this run
################################################################################
#MLoR
          MLoR = glm(formula = paste0(names(data)[41],"~."),
                     data = data,
                     family = "binomial"
          )
          regSummary = tidy(MLoR, exponentiate = TRUE, conf.level = 0.95)
          regSummary = regSummary[2:nrow(regSummary),] #Drop intercept
          regSummary = regSummary[order(regSummary$p.value), ]
          for (index in 1:NUM_FEATURES){
            Feature = regSummary[[index,1]]
            FeatureInd = which(names(Stunting) == Feature)
            FeatureList[[FeatureInd, 2]] = FeatureList[[FeatureInd, 2]] + 1
          }
          FSResults[[i]][[j]][[1]] = FeatureList[,c(1,2)]
################################################################################
#ChiSq
library(plyr)

          for (FeatureInd in 1:40){
            chisq = chisq.test(table(data[,FeatureInd],
                                     data[,41]
                                     )
                               )
            if (chisq$p.value < 0.05){
              FeatureList[[FeatureInd, 3]] = FeatureList[[FeatureInd, 3]] + 1
            }
          }
          FSResults[[i]][[j]][[2]] = FeatureList[,c(1,3)]
################################################################################
#mRMR. Pretty quick.
library(mRMRe)

          mrmr = mRMR.data(data = data)
          results = mRMR.classic("mRMRe.Filter",
                           data = mrmr,
                           target_indices = 41,
                           feature_count = NUM_FEATURES,
                           method = "exhaustive"
                           )
          for (index in 1:NUM_FEATURES){
            FeatureInd = results@filters[["41"]][[index,1]]
            FeatureList[[FeatureInd, 4]] = FeatureList[[FeatureInd, 4]] + 1
          }
          FSResults[[i]][[j]][[3]] = FeatureList[,c(1,4)]
################################################################################
#JMI
library(praznik)

          jmi = JMI(X = data[,-41],
                    Y = data[,41],
                    k = NUM_FEATURES
                    )
          for (index in 1:NUM_FEATURES){
            FeatureInd = jmi$selection[[index]]
            FeatureList[[FeatureInd, 5]] = FeatureList[[FeatureInd, 5]] + 1
          }
          FSResults[[i]][[j]][[4]] = FeatureList[,c(1,5)]
################################################################################
#Monte Carlo. Will take at least ~3 hours
library("rmcfs")
          #works!
          montecarlo = mcfs(formula = as.formula(paste0(names(data)[41],"~.")),
                            data = data,
                            cutoffPermutations = 0,
                            featureFreq = 50,
                            buildID = TRUE,
                            finalCV = FALSE,
                            finalRuleset = FALSE,
                            threadsNumber = 4
                            )
          
          results = montecarlo$RI
          for (index in 1:NUM_FEATURES){
            if (results[[index, 6]] > 0) { #if significance value > 0
              Feature = results[[index,2]]
              FeatureInd = which(names(Stunting) == Feature)
              FeatureList[[FeatureInd, 6]] = FeatureList[[FeatureInd, 6]] + 1
            }
          }
          FSResults[[i]][[j]][[5]] = FeatureList[,c(1,6)]
          
          #> df = FSResults[["Thinness"]][["Youth"]][["MC"]] #get subset result
          #> df = df[order(-df$MC),] #order by most important features
          #> df #print
################################################################################
        }
      }
  }
}
```



```{r FS Results}
#Goes through all results and removes anything that's not significant.
TopFeatures = FSResults

for (i in 1:3){
  for (j in 1:7){
    if (i == 3 & (j == 6 | j == 7)){ #Wasting has no youth/adolescent subsets; skip them
      next
    }
    for (k in 1:5){
      if (length(FSResults[[i]][[j]][[k]]) == 0){
        next
      }
      data = FSResults[[i]][[j]][[k]]
      Selected = integer()
      for (index in 1:40){
        if (data[[index, 2]] >= 95){
          Selected = c(Selected, index)
        }
      }
      TopFeatures[[i]][[j]][[k]] = TopFeatures[[i]][[j]][[k]][Selected,1]
    }
  }
}
```



```{r CART}
library("rpart")
library("rpart.plot")

CART = list("Stunting" = list("Full" = list(),
                                   "Urban" = list(),
                                   "Nonurban" = list(),
                                   "Male" = list(),
                                   "Female" = list(),
                                   "Youth" = list(),
                                   "Adolescent" = list()
                                   ),
                 "Thinness" = list("Full" = list(),
                                   "Urban" = list(),
                                   "Nonurban" = list(),
                                   "Male" = list(),
                                   "Female" = list(),
                                   "Youth" = list(),
                                   "Adolescent" = list()
                                   ),
                 "Wasting" = list("Full" = list(),
                                  "Urban" = list(),
                                  "Nonurban" = list(),
                                  "Male" = list(),
                                  "Female" = list(),
                                  "Youth" = list(),
                                  "Adolescent" = list()
                                  )
                 )

for (i in 2:2){ #1:3
  tree_depth = c(0.002, 0.0000001, 0.000001) #for S/T/W
  
  for (j in 1:7){ #1:7
    if (i == 3 & (j == 6 | j == 7)){ #Wasting has no youth/adolescent subsets; skip them
      next
    }
    data = DATA[[i]][[j]]

    train = sample(1:nrow(data), (nrow(data)/2))
    CART_train = data[train,]
    CART_test = data[-train,]
    
    test = data[-train]
    
    #Fit tree
    fit.tree = rpart(
      formula = as.formula(paste0(names(data)[ncol(data)],"~.")),
      data = CART_train,
      method = "class",
      cp = tree_depth[i] #Change depth depending on which subset to account for class imbalances
      )
    fit.tree
    
    CART[[i]][[j]] = fit.tree
    #visualize
    rpart.plot(fit.tree)
  }
}

#rpart.plot(CART[[1]][[1]])
#rpart.plot(CART[[2]][[1]])
#rpart.plot(CART[[3]][[1]])

```



```{r Linear Regression Prep}
#Prepares another dataset, but with Z-scores for Stunting/Thinness/Wasting
#instead of the binarized versions used previously.

StuntingZ = processed[,-c(3, 4, 44:48)]
imputed = kNN(StuntingZ, variable = colnames(StuntingZ), k = 5, impNA = TRUE) 
StuntingZ = subset(imputed, select = 1:41)

ThinnessZ = processed[,-c(3, 4, 43:44, 46:48)]
imputed = kNN(ThinnessZ, variable = colnames(ThinnessZ), k = 5, impNA = TRUE) 
ThinnessZ = subset(imputed, select = 1:41)

WastingZ = processed[,-c(3, 4, 43:46, 48)]
WastingZ = subset(WastingZ, Age < 11)
WastingZ$WAZ = as.numeric(as.character(WastingZ$WAZ))
imputed = kNN(WastingZ, variable = colnames(WastingZ), k = 5, impNA = TRUE) 
WastingZ = subset(imputed, select = 1:41)

DATAZ = list("Stunting" = list("Full" = list(), #DATAZ, for Z-scores
                              "Urban" = list(),
                              "Nonurban" = list(),
                              "Male" = list(),
                              "Female" = list(),
                              "Youth" = list(),
                              "Adolescent" = list()
                              ),
            "Thinness" = list("Full" = list(),
                              "Urban" = list(),
                              "Nonurban" = list(),
                              "Male" = list(),
                              "Female" = list(),
                              "Youth" = list(),
                              "Adolescent" = list()
                              ),
            "Wasting" = list("Full" = list(),
                              "Urban" = list(),
                              "Nonurban" = list(),
                              "Male" = list(),
                              "Female" = list()
                              )
            )
DATAZ[["Stunting"]][["Full"]] = StuntingZ
DATAZ[["Stunting"]][["Urban"]] = subset(StuntingZ, Urban == 1)
DATAZ[["Stunting"]][["Nonurban"]] = subset(StuntingZ, Urban == 0)
DATAZ[["Stunting"]][["Male"]] = subset(StuntingZ, Sex == 0)
DATAZ[["Stunting"]][["Female"]] = subset(StuntingZ, Sex == 1)
DATAZ[["Stunting"]][["Youth"]] = subset(StuntingZ, Age < 11)
DATAZ[["Stunting"]][["Adolescent"]] = subset(StuntingZ, Age > 10)

DATAZ[["Thinness"]][["Full"]] = ThinnessZ
DATAZ[["Thinness"]][["Urban"]] = subset(ThinnessZ, Urban == 1)
DATAZ[["Thinness"]][["Nonurban"]] = subset(ThinnessZ, Urban == 0)
DATAZ[["Thinness"]][["Male"]] = subset(ThinnessZ, Sex == 0)
DATAZ[["Thinness"]][["Female"]] = subset(ThinnessZ, Sex == 1)
DATAZ[["Thinness"]][["Youth"]] = subset(ThinnessZ, Age < 11)
DATAZ[["Thinness"]][["Adolescent"]] = subset(ThinnessZ, Age > 10)

DATAZ[["Wasting"]][["Full"]] = WastingZ
DATAZ[["Wasting"]][["Urban"]] = subset(WastingZ, Urban == 1)
DATAZ[["Wasting"]][["Nonurban"]] = subset(WastingZ, Urban == 0)
DATAZ[["Wasting"]][["Male"]] = subset(WastingZ, Sex == 0)
DATAZ[["Wasting"]][["Female"]] = subset(WastingZ, Sex == 1)

LinResults = list("Stunting" = list("Full" = list(),
                                   "Urban" = list(),
                                   "Nonurban" = list(),
                                   "Male" = list(),
                                   "Female" = list(),
                                   "Youth" = list(),
                                   "Adolescent" = list()
                                   ),
                 "Thinness" = list("Full" = list(),
                                   "Urban" = list(),
                                   "Nonurban" = list(),
                                   "Male" = list(),
                                   "Female" = list(),
                                   "Youth" = list(),
                                   "Adolescent" = list()
                                   ),
                 "Wasting" = list("Full" = list(),
                                  "Urban" = list(),
                                  "Nonurban" = list(),
                                  "Male" = list(),
                                  "Female" = list(),
                                  "Youth" = list(),
                                  "Adolescent" = list()
                                  )
                 )
```



```{r Linear Regression}
library(glmnet)

for (i in 1:3){
  for (j in 1:7){
    if (i == 3 & (j == 6 | j == 7)){
      next
    }
    data = DATAZ[[i]][[j]] #Get data subset
    linear = lm(paste0(names(data)[41],"~."), #Run linear regression
                data = data
                )
    stepwise = stepAIC(linear, direction = "both", trace = FALSE) #Improve with stepwise
    stepwise = tidy(stepwise, conf.level = 0.95) #Make it more readable
    stepwise = cbind(stepwise, #Put all the important bits together
                     p.adjust(stepwise$p.value, method = "BH")
                     )
    stepwise = stepwise[-1,] #Drop the intercept row
    significants = integer()
    for (k in 1:nrow(stepwise)){ #Drop anything that's not significant
      if(stepwise[[k, 5]] <= 0.05){
        significants = c(significants, k)
      }
    }
    stepwise = stepwise[significants,]
    LinResults[[i]][[j]] = stepwise
  }
}
```



```{r Multivariate Logistic Regression (OR), warning = FALSE}
#library(devtools)
library(broom)
library(car)
library(performance)
library(MASS)
library(leaps)
library(pwr)

#NOTE!!

#Some factors in the subsets of data have the same value, which breaks the below
#code. They're being removed here to make it work - if you're going to re-run
#any code from before this point, please first re-run line ~760 which handles
#the creation of dataframe "DATA".


DATA[[1]][[2]] = DATA[[1]][[2]][,-6]
DATA[[1]][[3]] = DATA[[1]][[3]][,-6]
DATA[[1]][[4]] = DATA[[1]][[4]][,-2]
DATA[[1]][[5]] = DATA[[1]][[5]][,-2]
DATA[[1]][[6]] = DATA[[1]][[6]][,-1]
DATA[[1]][[7]] = DATA[[1]][[7]][,-1]

DATA[[2]][[2]] = DATA[[2]][[2]][,-6]
DATA[[2]][[3]] = DATA[[2]][[3]][,-6]
DATA[[2]][[4]] = DATA[[2]][[4]][,-2]
DATA[[2]][[5]] = DATA[[2]][[5]][,-2]
DATA[[2]][[6]] = DATA[[2]][[6]][,-1]
DATA[[2]][[7]] = DATA[[2]][[7]][,-1]

DATA[[3]][[2]] = DATA[[3]][[2]][,-6]
DATA[[3]][[3]] = DATA[[3]][[3]][,-6]
DATA[[3]][[4]] = DATA[[3]][[4]][,-2]
DATA[[3]][[5]] = DATA[[3]][[5]][,-2]

RegResults = list("Stunting" = list("Full" = list(),
                                   "Urban" = list(),
                                   "Nonurban" = list(),
                                   "Male" = list(),
                                   "Female" = list(),
                                   "Youth" = list(),
                                   "Adolescent" = list()
                                   ),
                 "Thinness" = list("Full" = list(),
                                   "Urban" = list(),
                                   "Nonurban" = list(),
                                   "Male" = list(),
                                   "Female" = list(),
                                   "Youth" = list(),
                                   "Adolescent" = list()
                                   ),
                 "Wasting" = list("Full" = list(),
                                  "Urban" = list(),
                                  "Nonurban" = list(),
                                  "Male" = list(),
                                  "Female" = list(),
                                  "Youth" = list(),
                                  "Adolescent" = list()
                                  )
                 )

for (i in 1:3){
  for (j in 1:7){
    if (i == 3 & (j == 6 | j == 7)){
      next
    }
      data = DATA[[i]][[j]]
      if (j == 3){
        if (i == 2){
          data = data[,-c(15,31,33)]
        }else if (i == 3){
          data = data[,-c(15,20,31,33,36)]
        }
      }
      reg = glm(paste0(names(data)[ncol(data)],"~."),
                data = data,
                family = "binomial"
                )
      
      #Power calculation! McFadden's R^2
      r2 = with(summary(reg), 1 - deviance/null.deviance)
      df_num = 40 - 1 # predictors - 1
      df_denom = 1032 - 40 #sample size - predictors
      effectSize = r2/(1-r2)
      power = pwr.f2.test(u = df_num, v = df_denom, f2 = effectSize, sig.level = 0.05)
      power = power$power
      
      tidied = tidy(reg, exponentiate = TRUE, conf.level = 0.95, n = length(data))
      results = cbind(tidied,
                      p.adjust(tidied$p.value, method = "BH"),
                      exp(confint(na.omit(reg))),
                      power
                      )
      RegResults[[i]][[j]] = results
  }
}
```

```{r MVLoR Power Analysis}
library(WebPower)

prob0 = sum(Stunting$Stunting == 0) / 1032
prob1 = 1 - prob0

prob0=0.15
prob1=0.1

wp.logistic(n = 1032, p0 = prob0, p1 = prob1, alpha = 0.05,
  power = NULL, alternative = "two.sided", family = "Bernoulli", parameter = 0.5)
```

# ARL:
######

```{r Association Rule Learning Prep}
#Pretty quick.
#I played around with support and confidence values until I got ~10 rules per iteration of the Apriori algorithm. 
set.seed(13)

library(arules)
library(arulesViz)

#Make data structure to store important results
ruleSet = data.frame(rules = character(),
                     support = numeric(),
                     confidence = numeric(),
                     coverage = numeric(),
                     lift = numeric(),
                     count = numeric(),
                     oddsRatios = numeric(),
                     pVal = numeric()
                     )
```



```{r Stunting Rules}
set.seed(13)
################################################################################
#Male vs. Female associations on Stunting
ruleSet[nrow(ruleSet)+1, 1] = "Stunting:"
data = data.frame(lapply(Stunting, as.logical))

ruleSet[nrow(ruleSet)+1, 1] = "FEMALE:"
female = subset(data, Sex == TRUE)
female = female[,-2]
rules = apriori(female, 
                parameter = list(support = 0.01,
                                 confidence = 0.3,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Stunting")
                                  )
                )
#inspect(rules[1:10])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "MALE:"
male = subset(data, Sex == FALSE)
male = male[,-2]
rules = apriori(male, 
                parameter = list(support = 0.01,
                                 confidence = 0.5,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Stunting")
                                  )
                )
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))
################################################################################
#Rural & suburban vs. urban rules on Stunting
ruleSet[nrow(ruleSet)+1, 1] = "NOTURBAN:"
rural = subset(data, Urban == FALSE)
rural = rural[,-c(6)]
rules = apriori(rural,
                parameter = list(support = 0.01,
                                 confidence = 0.4,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Stunting")
                                  )
                )
#inspect(rules)
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "URBAN:"
urban = subset(data, Urban == TRUE)
urban = urban[,-c(6)]
rules = apriori(urban, 
                parameter = list(support = 0.01,
                                 confidence = 0.4,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Stunting")
                                  )
                )
#inspect(rules[1:8])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))
################################################################################
ruleSet[nrow(ruleSet)+1, 1] = "Stunting OVERALL:"
rules = apriori(data.frame(lapply(Stunting, as.logical)), 
                parameter = list(support = 0.01,
                                 confidence = 0.3,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Stunting")
                                  )
                )
#inspect(rules[1:10])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "StuntingYOUNG OVERALL:"

rules = apriori(data.frame(lapply(subset(Stunting, (Age < 11)), as.logical)), 
                parameter = list(support = 0.01,
                                 confidence = 0.4,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Stunting")
                                  )
                )
#inspect(rules[1:8])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "StuntingADOLESCENT OVERALL:"

rules = apriori(data.frame(lapply(subset(Stunting, (Age > 10)), as.logical)), 
                parameter = list(support = 0.01,
                                 confidence = 0.5,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Stunting")
                                  )
                )
#inspect(rules[1:8])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))
```



```{r Association Rule Learning: Thinness}
set.seed(13)
################################################################################
ruleSet[nrow(ruleSet)+1, 1] = "Thinness:"
data = data.frame(lapply(Thinness, as.logical))


ruleSet[nrow(ruleSet)+1, 1] = "FEMALE:"
female = subset(data, Sex == TRUE)
female = female[,-2]
rules = apriori(female, 
                parameter = list(support = 0.002,
                                 confidence = 0.15,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Thinness")
                                  )
                )
#append(ruleSet, as(rules, "data.frame"))
#inspect(rules)
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "MALE:"
male = subset(data, Sex == FALSE)
male = male[,-2]
rules = apriori(male, 
                parameter = list(support = 0.002,
                                 confidence = 0.2,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Thinness")
                                  )
                )
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))
################################################################################
#Rural & suburban vs. urban rules on Thinness
ruleSet[nrow(ruleSet)+1, 1] = "NOTURBAN:"
rural = subset(data, Urban == FALSE)
rural = rural[,-c(6)]
rules = apriori(rural,
                parameter = list(support = 0.005,
                                 confidence = 0.2,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Thinness")
                                  )
                )
#inspect(rules)
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "URBAN:"
urban = subset(data, Urban == TRUE)
urban = urban[,-c(6)]
rules = apriori(urban, 
                parameter = list(support = 0.002,
                                 confidence = 0.15,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Thinness")
                                  )
                )
#inspect(rules[1:8])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))
################################################################################
ruleSet[nrow(ruleSet)+1, 1] = "Thinness OVERALL:"
rules = apriori(data.frame(lapply(Thinness, as.logical)), 
                parameter = list(support = 0.001,
                                 confidence = 0.12,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Thinness")
                                  )
                )
#inspect(rules[1:10])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "ThinnessYOUNG OVERALL:"

rules = apriori(data.frame(lapply(subset(Thinness, (Age < 11)), as.logical)), 
                parameter = list(support = 0.002,
                                 confidence = 0.15,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Thinness")
                                  )
                )
#inspect(rules[1:8])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "ThinnessADOLESCENT OVERALL:"

rules = apriori(data.frame(lapply(subset(Thinness, (Age > 10)), as.logical)), 
                parameter = list(support = 0.003,
                                 confidence = 0.15,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Thinness")
                                  )
                )
#inspect(rules[1:8])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))
```




```{r Association Rule Learning: WastingYoung}
set.seed(13)
#Pretty quick.
#Again, same as above two blocks except only conducted on WastingYoung data.
################################################################################
ruleSet[nrow(ruleSet)+1, 1] = "Wasting:"
data = data.frame(lapply(Wasting, as.logical))


ruleSet[nrow(ruleSet)+1, 1] = "FEMALE:"
female = subset(data, Sex == TRUE)
female = female[,-2]
rules = apriori(female, 
                parameter = list(support = 0.01,
                                 confidence = 0.2,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Wasting")
                                  )
                )
#append(ruleSet, as(rules, "data.frame"))
#inspect(rules)
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "MALE:"
male = subset(data, Sex == FALSE)
male = male[,-2]
rules = apriori(male, 
                parameter = list(support = 0.01,
                                 confidence = 0.25,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Wasting")
                                  )
                )
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))
################################################################################
#Rural & suburban vs. urban rules on Wasting
ruleSet[nrow(ruleSet)+1, 1] = "NOTURBAN:"
rural = subset(data, Urban == FALSE)
rural = rural[,-c(6)]
rules = apriori(rural,
                parameter = list(support = 0.01,
                                 confidence = 0.3,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Wasting")
                                  )
                )
#inspect(rules)
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))

ruleSet[nrow(ruleSet)+1, 1] = "URBAN:"
urban = subset(data, Urban == TRUE)
urban = urban[,-c(6)]
rules = apriori(urban, 
                parameter = list(support = 0.005,
                                 confidence = 0.15,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Wasting")
                                  )
                )
#inspect(rules[1:8])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))
################################################################################
ruleSet[nrow(ruleSet)+1, 1] = "Wasting OVERALL:"
rules = apriori(data.frame(lapply(Wasting, as.logical)), 
                parameter = list(support = 0.005,
                                 confidence = 0.15,
                                 maxlen = 4,
                                 target = "rules"),
                appearance = list(default = "lhs", rhs = c("Wasting")
                                  )
                )
#inspect(rules[1:10])
rules = sort(rules, decreasing = TRUE, na.last = NA, by = "lift")
rules = rules[1:20]
quality(rules)$oddsRatios = interestMeasure(rules, measure = "oddsRatio")
quality(rules)$pVal = interestMeasure(rules, measure = "fishersExactTest")
ruleSet = rbind(ruleSet, as(rules, "data.frame"))
#quality(rules)$t = interestMeasure(rules, measure = "table")
################################################################################
write.csv(ruleSet, "Association_Rules.csv", row.names = FALSE)
```



```{r Association Rule Sets Analysis}
RiskSets = list(list("HousePet", "DontUseTP", "Chicken"), #Stunting
             list("HousePet", "DontUseTP", "washHandsSoapB4Eat"),
             
             # list("Urban", "Chicken", "DontUseTP"),
             # list("HousePet", "RiverCleaning", "momFinished2Up"),
             # list("Chicken", "DontUseTP", "washHandsSoapB4Eat"),
             # list("HousePet", "DontTreatWater", "DontUseTP"),
             
             list("DefecateField", "Antibiotics", "RiverCleaning"), #Wasting
             list("HousePet", "Antibiotics", "RiverCleaning"),
             list("DefecateField", "Antibiotics", "WalkBarefoot"),
             # list("DefecateField", "Antibiotics", "RiverCleaning"),
             # list("DefecateField", "WalkBarefoot", "Antibiotics"),
             # list("Vaccine", "Antibiotics", "houseDustFloor"),
             # list("HousePet", "Antibiotics", "RiverCleaning"),
             # list("CookElectric", "Antibiotics", "RiverCleaning"),
             
                
             list("houseDustFloor", "Rash", "momFinishedPrimary"), #Thinness
             list("SheepGoat", "PotableWaterFromHouse", "momFinishedPrimary"),
             list("SheepGoat", "EatRawVeg", "momFinishedPrimary"),
             list("DefecateField", "Antibiotics", "momFinishedPrimary")
             
             # list("SheepGoat", "PotableWaterFromHouse", "momFinishedPrimary"),
             # list("SheepGoat", "EatRawVeg", "momFinishedPrimary"),
             # list("Rash", "houseDustFloor", "momFinished2Up"),
             # list("HousePet", "DefecateField", "Antibiotics"),
             # list("DefecateField", "Antibiotics", "momFinishedPrimary")
             )
RiskSetsResponse = c(rep(1,2), #First 2 groups go with Stunting (index 1)
                     rep(3,3), #Next 3, with Wasting (index 3)
                     rep(2,4) #Last 4, with Thinness (index 2)
                     )

# ProtectSets = list(list("Vaccine", "PotableWaterFromHouse", "DontUseSchoolLat"), #Stunting
#                    list("Vaccine", "PotableWaterFromHouse", "momFinished2Up"),
#                    list("Vaccine", "CookElectric", "washHandsLatWaterSoap"),
#                    
#                    list("Vaccine", "CookElectric", "momFinished2Up"), #Wasting
#                    list("Chicken", "HousePet", "EatSoil"),
#                    list("Chicken", "HousePet", "RadioTV"),
#                    list("CookElectric", "EatSoil", "momFinished2Up"),
#                    
#                    #Thinness
#                    list("PotableWaterFromHouse", "DontTreatWater", "DontUseSchoolLat"),
#                    list("PotableWaterFromHouse", "DontTreatWater", "washHandsLatWater"),
#                    list("KitchenSeparate", "DontUseSchoolLat", "washHandsLatWaterSoap")
#                    )
# ProtectSetsResponse = c(rep(1,3), #Same pattern as RiskSetsResponse above
#                         rep(3,4),
#                         rep(2,3)
#                         )
```



```{r ChiSq, Odds Ratio Analysis of ARL Risk Factors}
library(epitools)
library(DescTools)

RiskResults = list("Stunting" = list(),
                   "Thinness" = list(),
                   "Wasting" = list()
                   )

setindex = 0
for (setnum in 1:9){
  #From Stunting, Thinness, or Wasting? Check next in list
  setindex = setindex + 1
  responseset = RiskSetsResponse[setindex]
  #Now that we know which dataset we need, get it
  data = DATA[[responseset]][[1]]
  #Figure out which features we want to run the MLoR on
  selected = RiskSets[[setnum]]
  selected = append(selected, names(data)[ncol(data)]) #Add the response variable
  #Figure out where these features are located
  indices = c()
  for (feature in selected){
    index = which(names(data) == feature)
    indices = c(indices, index)
  }
  #Subset data into variables + response
  data = data[,indices]
  data$Positive = 0
  for (i in 1:nrow(data)){
    count = 0
    for (j in 1:(ncol(data)-2)){ #Skip response variable & new "Positive" column
      count = count + data[[i,j]]
    }
    if (count > 0){
      data[[i,ncol(data)]] = 1
    }
  }
  data = data[,c(ncol(data)-1, ncol(data))]
  #Create table with 0 as reference category
  datatable = table(data)
  # #Weird correction
  # for (v in 1:2){
  #   for (h in 1:2){
  #     #if (datatable[[v,h]] == 0){
  #       datatable[[v,h]] = datatable[[v,h]] + 0.5
  #     #}
  #   }
  # }
  test = oddsratio(datatable, correction = FALSE)
  adj = oddsratio(datatable, correction = TRUE) #Run again for adjusted PVs
  
  # test$p.value = test$p.value[[2,3]]
  # test$measure = test$measure[2,]
  # test$adj.PV = adj$p.value[[2,3]]
  
  probs = datatable/sum(datatable)
  
  #power analysis
  power = pwr.chisq.test(w = ES.w2(probs),
                 N = sum(datatable),
                 df = 1, #categories - 1
                 sig.level = 0.05,
                 ) 
  test[['power']] = power$power
  
  RiskResults[[responseset]][[length(RiskResults[[responseset]])+1]] = test #Make a space in the results for this specific test, then store it there
  newname = ""
  for (features in 1:(length(selected)-1)){
    newname = paste0(newname, selected[[features]],"_")
  }
  newname = paste0(newname, "==>", selected[[length(selected)]])
  names(RiskResults[[responseset]])[[length(RiskResults[[responseset]])]] = newname
}

```


