---
title: "Logistic Regression"
author: "Jim Perry"
date: "5/26/2022"
output: pdf_document
---

```{r Multivariate Logistic Regression}
data = read.csv("stunting.csv")
#this is the vector with all the columns, for multivariate analysis.
#This code performs the multivariate logistic regressions for each outcome.
MV_logi = glm(Stunting~., data = data, family = "binomial")
#summary(MV_logi)
#tidy(MV_logi, exponentiate = TRUE, conf.level = 0.95) #turns logodds to odds, makes it pretty

#This code writes the results to multiple csv files.
# write.csv(cbind(attr((MV_logi$terms), "term.labels"),
#                 p.adjust(summary(MV_logi)$coefficients[1:length(columns)+1,4],
#                          method = "BH"),
#                 exp(summary(MV_logi)$coef[1:length(columns)+1]),
#                 exp(confint(MV_logi))[1:length(columns)+1, 1:2]),
#           file = paste("MVLoR",responseVar,".csv",sep=""),
#                  row.names = F)

"
P-VALUES IN .csv ARE SHIFTED ONE BLOCK DOWN; ASK AZIZ.
Doesn't want to output anything for last variable; somehow OOB.
"
write.csv(cbind(attr((MV_logi$terms), "term.labels"), #Variable names
                (MV_logi)$coefficients[1:length(columns)+1,4], #p-vals
                exp(summary(MV_logi)$coef[1:length(columns)+1]), #odds ratio -1
                exp(confint(MV_logi))[1:length(columns)+1, 1:2]), #OR CI
          file = paste("MVLoR_",responseVar,".csv", sep = ""), row.names = F)
```

```{r Univariate Logistic Regression, warning = FALSE}
#This code creates blank data frames for univariate logistic regression models.
UV_logi_DF = data.frame(Variable_Name=character(),
                         C_Odds_Ratio=numeric(),
                         Conf_025=numeric(),
                         Conf_975=numeric(),
                         P_Value=numeric()
                         )

#This code performs univariate analysis (by groups), and then appends the results
#to the data frames made in the above code.
for (factor in 1:length(columns_grouped)){
  vec = unlist(columns_grouped[factor])
  factor = paste(vec,
            collapse = "+"
            )
  uni_model = glm(paste(responseVar, " ~ ", factor, sep = ""),
                      data = data,
                      family ="binomial"
                      )
  trm <- attr(uni_model$terms, "term.labels")
  for (result in 1:length(vec)){ #for each result value in returned vector
    print(result)
    uni <- c(trm[result],
                 (exp(summary(uni_model)$coef[result,][1])), #odds ratio
                 exp((confint(uni_model)[result,])), #odds ratio confidence interval
                 (summary(uni_model)$coef[result,][4]) #p-value
                 )
    UV_logi_DF[nrow(UV_logi_DF) + 1,] = uni
  }
}

#This replaces NAs with 0 (in case the probabilities could not fit to 0 or 1)
UV_logi_DF[is.na(UV_logi_DF)] <- 0
#Adjusting the p-values
UV_logi_DF$P_Value = p.adjust(UV_logi_DF$P_Value)#, method = "BH")
#This writes the results to csv files.
write.csv(UV_logi_DF,
          file = paste("UVLoR_",responseVar,".csv", sep = ""),
          row.names = FALSE)

#This code is optional, for visual ease. 
#create_table <- function(dataframe, label) {
#  kableExtra::kable_styling(knitr::kable(dataframe[dataframe$P_Value <= 0.05,],
#                                         booktabs = TRUE, 
#                                         caption = label
#                                         ),
#                            font_size = 10
#                            )
#}

#create_table(UV_logi_DF, responseVar)
```
#This code finds the frequencies of positive and negative cases for each risk factor
df_counts = data.frame(Var_name = character(), 
                       true_count = character(),
                       false_count = character())

for (i in 1:length(columns)){
  v = c(columns[i], 
        paste(length(which(data[columns[i]] == 1 & data[responseVar] == 1)),
        " (",round(length(which(data[columns[i]] == 1 & 
        data[responseVar]==1)) / length(which(data[columns[i]] == 1))*100,1),
        ")%",
        sep =""),
        paste(length(which(data[columns[i]] == 1 & data[responseVar]==0)),
        " (",
        round(length(which(data[columns[i]] == 1))))
        )
  df_counts[nrow(df_counts) + 1,] = v
}

#This prints the results to a csv file.
write.csv(df_counts, 
          file = paste("CaseFrequency_",responseVar,".csv", sep = ""), 
          row.names = FALSE)
```
